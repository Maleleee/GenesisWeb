<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Sharp" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', filename='styleadminv2.css') }}" />
    <title>Admin Dashboard V2 Genesis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
    <div class="container">
        <!-- Sidebar Section -->
        <aside>
            <div class="toggle">
                <div class="logo">
                    <img src="{{ url_for('static', filename='images/genesisicon.png') }}" />
                    <h2>GENESIS</h2>
                </div>
                <div class="close" id="close-btn">
                    <span class="material-icons-sharp">close</span>
                </div>
            </div>

            <div class="sidebar">
                <a href="#" class="active" onclick="showContent('analytics')">
                    <span class="material-icons-sharp">insights</span>
                    <h3>Analytics</h3>
                </a>

                <a href="#" onclick="showContent('reports')">
                    <span class="material-icons-sharp">report_gmailerrorred</span>
                    <h3>Reports</h3>
                </a>

                <a id="logout" class="logout" href="/logout">
                    <span class="material-icons-sharp">logout</span>
                    <h3>Logout</h3>
                </a>
            </div>
        </aside>
        <!-- End of Sidebar Section -->

        <!-- Main Content -->
        <main id="mainContent">
            <div id="analyticsContent">
                <h1>Analytics</h1>
                <div class="analyse">
                    <div class="sales">
                        <div class="status">
                            <div class="info">
                                <h3>Total Users </h3> 
                                <h1>{{ total_users }}</h1>
                            </div>
                            <div class="progresss">
                                <svg>
                                    <circle cx="38" cy="38" r="36"></circle>
                                </svg>
                            </div>
                        </div>
                    </div>
                    <div class="visits">
                        <div class="status">
                            <div class="info">
                                <h3>Site Visit</h3>
                            </div>
                            <div class="progresss">
                                <svg>
                                    <circle cx="38" cy="38" r="36"></circle>
                                </svg>
                            </div>
                        </div>
                    </div>
                    <div class="searches">
                        <div class="status">
                            <div class="info">
                                <h3>Searches</h3>
                            </div>
                            <div class="progresss">
                                <svg>
                                    <circle cx="38" cy="38" r="36"></circle>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- User Data Table Section -->
                <div class="user-data">
                <h2>User Data</h2>
                <div class="filter-group">
                    <input type="text" id="ipFilter" placeholder="Filter by IP Address" onkeyup="filterTable()" aria-label="Filter by IP Address">
                    <input type="text" id="labelFilter" placeholder="Filter by Label" onkeyup="filterTable()" aria-label="Filter by Label">
                </div>
                
                <table>
                    <thead>
                        <tr>
                            <th scope="col">Timestamp</th>
                            <th scope="col">IP Address</th>
                            <th scope="col">Packet Size</th>
                            <th scope="col">Request Rate</th>
                            <th scope="col">Label</th>
                        </tr>
                    </thead>
                    <tbody id="userDataBody">
                        <!-- Initially empty; rows will be appended here by JavaScript -->
                    </tbody>
                </table>
                <div id="pagination">
                    <button id="prevBtn" onclick="changePage(-1)">Previous</button>
                    <input type="number" id="pageInput" placeholder="Page" min="1" aria-label="Page #" />
                    <span id="pageInfo"></span>
                    <button id="nextBtn" onclick="changePage(1)">Next</button>
                </div> <!-- Pagination controls -->
                </div>
                <!-- End of User Data Table Section -->

                <!-- Recent Logins Table -->
                <div class="recent-logins">
                    <h2>Recent Logins</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Timestamp</th>
                                <th>Email</th>
                                <th>Username</th>
                            </tr>
                        </thead>
                        <tbody id="recentLoginsBody">
                            <!-- Initially empty; rows will be appended here by JavaScript -->
                        </tbody>
                    </table>
                    <div id="pagination">
                        <button id="loginPrevBtn" onclick="changeLoginPage(-1)">Previous</button>
                        <input type="number" id="loginPageInput" placeholder="Page" min="1" aria-label="Page number" />
                        <span id="loginPageInfo"></span>
                        <button id="loginNextBtn" onclick="changeLoginPage(1)">Next</button>
                    </div> <!-- Pagination controls -->
                </div>
                <!-- End of Recent Logins -->
            </div>
            <div id="reportsContent" style="display: none;">
                <h1>Reports</h1>
                <canvas id="attackChart"></canvas>
                <div>
                    <button class="styled-button" onclick="updateChart('24h')">24h</button>
                    <button class="styled-button" onclick="updateChart('168h')">7d</button>
                    <button class="styled-button" onclick="updateChart('30d')">1m</button>
                    <button class="styled-button" onclick="updateChart('90d')">3m</button>
                    <button class="styled-button" onclick="updateChart('6m')">6m</button>
                    <button class="styled-button" onclick="updateChart('12m')">1y</button>
                    <button class="styled-button" onclick="updateChart('all')">All</button>
                </div>
            </div>
        </main>
        <!-- End of Main Content -->

        <!-- Right Section -->
        <div class="right-section">
            <div class="nav">
                <button id="menu-btn"><span class="material-icons-sharp">menu</span></button>
                <div class="dark-mode">
                    <span class="material-icons-sharp active">light_mode</span>
                    <span class="material-icons-sharp">dark_mode</span>
                </div>

                <div class="profile">
                    <div class="info">
                        <p>Hey, <b>Allen</b></p>
                        <small class="text-muted">Admin</small>
                    </div>
                    <div class="profile-photo">
                        <img src="{{ url_for('static', filename='images/adminv2.png') }}" />
                    </div>
                </div>
            </div>
            <!-- End of Nav -->

            <div class="user-profile">
                <div class="logo">
                    <img src="{{ url_for('static', filename='images/genesisicon.png') }}" />
                    <h2>Genesis</h2>
                </div>
            </div>

            <div class="reminders">
                <div class="header">
                    <h2>Reminders</h2>
                    <span class="material-icons-sharp">notifications_none</span>
                </div>

                <div class="notification">
                    <div class="icon">
                        <span class="material-icons-sharp">volume_up</span>
                    </div>
                    <div class="content">
                        <div class="info">
                            <h3>Finish ML Model</h3>
                            <small class="text_muted">All Day</small>
                        </div>
                        <span class="material-icons-sharp">more_vert</span>
                    </div>
                </div>

                <div class="notification deactive">
                    <div class="icon">
                        <span class="material-icons-sharp">edit</span>
                    </div>
                    <div class="content">
                        <div class="info">
                            <h3>Cry</h3>
                            <small class="text_muted">08:00 AM - 12:00 PM</small>
                        </div>
                        <span class="material-icons-sharp">more_vert</span>
                    </div>
                </div>

                <div class="notification add-reminder">
                    <div>
                        <span class="material-icons-sharp">add</span>
                        <h3>Add Reminder</h3>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <br>

    <script>
        let currentPage = 1;
        const rowsPerPage = 5;
        let totalRows = 0; // To keep track of total rows
        let attackData = []; // Store fetched data
        let attackChart;
        let isTimerTriggered = false; // Flag to check if refresh is triggered by timer
        let currentTimeRange = '24h'; // Default time range

        function fetchAttackData() {
            fetch('/get_attack_data')
                .then(response => response.json())
                .then(data => {
                    attackData = data.reverse(); // Store fetched data
                    totalRows = attackData.length; // Update total rows
                    displayPage(currentPage); // Display the current page
                    setupPagination(totalRows, false); // Setup pagination without updating input
                    filterTable(); // Reapply filters after data refresh
                    isTimerTriggered = false; // Reset the flag after manual refresh
                })
                .catch(error => console.error('Error fetching attack data:', error));
        }

        function setupPagination(totalRows, updateInput = true) {
            const totalPages = Math.ceil(totalRows / rowsPerPage);
            document.getElementById('pageInfo').innerText = ` of ${totalPages}`;
            document.getElementById('prevBtn').disabled = currentPage === 1;
            document.getElementById('nextBtn').disabled = currentPage === totalPages;
            document.getElementById('pageInput').max = totalPages; // Set max input value
            
            // Update the input value only if updateInput is true
            if (updateInput) {
                document.getElementById('pageInput').value = currentPage; // Set current page in input
            }
        }

        function changePage(direction) {
            const totalPages = Math.ceil(totalRows / rowsPerPage);
            currentPage += direction;
            currentPage = Math.max(1, Math.min(currentPage, totalPages)); // Ensure currentPage stays within bounds
            displayPage(currentPage); // Display the current page
            setupPagination(filteredData.length || totalRows); // Update pagination info
        }

        function goToPage() {
            const totalFilteredRows = attackData.filter(item => {
                const ipFilter = document.getElementById('ipFilter').value.toLowerCase();
                const labelFilter = document.getElementById('labelFilter').value.toLowerCase();
                const ipMatch = item.ip.toLowerCase().includes(ipFilter);
                const labelMatch = item.label.toLowerCase().includes(labelFilter);
                return ipMatch && labelMatch; // Return true if both match
            }).length; // Get the count of filtered rows

            const totalPages = Math.ceil(totalFilteredRows / rowsPerPage); // Calculate total pages based on filtered data
            const inputPage = parseInt(document.getElementById('pageInput').value);
            if (inputPage >= 1 && inputPage <= totalPages) {
                currentPage = inputPage; // Set current page to input value
                displayPage(currentPage); // Display the current page
                setupPagination(filteredData.length || totalRows); // Update pagination info
            } else {
                alert(`Please enter a valid page number between 1 and ${totalPages}.`);
            }
        }

        function displayPage(page) {
            const userDataBody = document.getElementById('userDataBody');
            userDataBody.innerHTML = ''; // Clear current data

            // Filter the attack data based on the current filter inputs
            const ipFilter = document.getElementById('ipFilter').value.toLowerCase();
            const labelFilter = document.getElementById('labelFilter').value.toLowerCase();
            
            const filteredData = attackData.filter(item => {
                const ipMatch = item.ip.toLowerCase().includes(ipFilter);
                const labelMatch = item.label.toLowerCase().includes(labelFilter);
                return ipMatch && labelMatch; // Return true if both match
            });

            // Calculate the start and end indices for pagination
            const start = (page - 1) * rowsPerPage;
            const end = start + rowsPerPage;
            const paginatedData = filteredData.slice(start, end); // Use filtered data

            // Display the paginated filtered data
            paginatedData.forEach(item => {
                const row = document.createElement('tr');
                const formattedTimestamp = new Date(item.timestamp * 1000).toISOString().slice(0, 19).replace('T', ' '); // Format timestamp
                row.innerHTML = `
                    <td>${formattedTimestamp}</td>
                    <td>${item.ip}</td>
                    <td>${item.packet_size}</td>
                    <td>${item.request_rate}</td>
                    <td>${item.label}</td>
                `;
                userDataBody.appendChild(row);
            });

            // Only refresh the page input value if not triggered by timer
            if (!isTimerTriggered) {
                setupPagination(filteredData.length); // Update pagination based on filtered data
            } else {
                setupPagination(filteredData.length, false);
            }
        }

        // Fetch data every 10 seconds
        setInterval(() => {
            isTimerTriggered = true; // Set the flag before fetching data
            fetchAttackData();
        }, 10000);
        // Initial fetch
        fetchAttackData();

        // Function to set a cookie
        function setCookie(name, value, days) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = name + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/';
        }

        // Function to get a cookie
        function getCookie(name) {
            return document.cookie.split('; ').reduce((r, v) => {
                const parts = v.split('=');
                return parts[0] === name ? decodeURIComponent(parts[1]) : r;
            }, '');
        }

        // Check cookie on page load to set initial mode
        window.onload = () => {
            const mode = getCookie('darkMode');
            if (mode === 'true') {
                document.body.classList.add('dark-mode-variables');
                darkMode.querySelector('span:nth-child(1)').classList.remove('active');
                darkMode.querySelector('span:nth-child(2)').classList.add('active');
            }
        };

        // Event listeners for sidebar and dark mode toggle
        const sideMenu = document.querySelector('aside');
        const menuBtn = document.getElementById('menu-btn');
        const closeBtn = document.getElementById('close-btn');
        const darkMode = document.querySelector('.dark-mode');

        menuBtn.addEventListener('click', () => {
            sideMenu.style.display = 'block';
        });

        closeBtn.addEventListener('click', () => {
            sideMenu.style.display = 'none';
        });

        darkMode.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode-variables');
            darkMode.querySelector('span:nth-child(1)').classList.toggle('active');
            darkMode.querySelector('span:nth-child(2)').classList.toggle('active');
        });

        // Function to filter table by label
        function filterTable() {
            const ipFilter = document.getElementById('ipFilter').value.toLowerCase();
            const labelFilter = document.getElementById('labelFilter').value.toLowerCase();
            const userDataBody = document.getElementById('userDataBody');
            
            // Clear current data
            userDataBody.innerHTML = '';

            // Filter the attack data based on the input values
            const filteredData = attackData.filter(item => {
                const ipMatch = item.ip.toLowerCase().includes(ipFilter);
                const labelMatch = item.label.toLowerCase().includes(labelFilter);
                return ipMatch && labelMatch; // Return true if both match
            });

            // Check if the current page exceeds the number of filtered results
            const totalFilteredRows = filteredData.length;
            const totalPages = Math.ceil(totalFilteredRows / rowsPerPage);
            if (currentPage > totalPages) {
                currentPage = totalPages; // Reset to the last valid page
            }

            // Display the filtered data
            displayFilteredData(filteredData); // Call a new function to display filtered data
        }

        function showContent(content) {
            const analyticsContent = document.getElementById('analyticsContent');
            const reportsContent = document.getElementById('reportsContent');

            if (content === 'analytics') {
                analyticsContent.style.display = 'block';
                reportsContent.style.display = 'none';
                document.querySelector('.active').classList.remove('active');
                document.querySelector('a[onclick="showContent(\'analytics\')"]').classList.add('active');
            } else if (content === 'reports') {
                analyticsContent.style.display = 'none';
                reportsContent.style.display = 'block';
                document.querySelector('.active').classList.remove('active');
                document.querySelector('a[onclick="showContent(\'reports\')"]').classList.add('active');
                updateChart(currentTimeRange);
            }
        }

        let currentLoginPage = 1;
        const loginRowsPerPage = 5;
        let totalLoginRows = 0; // To keep track of total login rows
        let recentLoginData = []; // Store fetched login data

        function fetchRecentLoginData() {
            fetch('/get_recent_login_data') // Adjust this endpoint as necessary
                .then(response => response.json())
                .then(data => {
                    recentLoginData = data; // Store fetched data
                    totalLoginRows = recentLoginData.length; // Update total rows
                    setupLoginPagination(); // Setup pagination
                    displayLoginPage(currentLoginPage); // Display the first page
                })
                .catch(error => console.error('Error fetching recent login data:', error));
        }

        function setupLoginPagination() {
            const totalLoginPages = Math.ceil(totalLoginRows / loginRowsPerPage);
            document.getElementById('loginPageInfo').innerText = ` of ${totalLoginPages}`;
            document.getElementById('loginPrevBtn').disabled = currentLoginPage === 1;
            document.getElementById('loginNextBtn').disabled = currentLoginPage === totalLoginPages;
            document.getElementById('loginPageInput').max = totalLoginPages; // Set max input value
            document.getElementById('loginPageInput').value = currentLoginPage; // Set current page in input
        }

        function changeLoginPage(direction) {
            const totalLoginPages = Math.ceil(totalLoginRows / loginRowsPerPage);
            currentLoginPage += direction;
            currentLoginPage = Math.max(1, Math.min(currentLoginPage, totalLoginPages)); // Ensure currentPage stays within bounds
            displayLoginPage(currentLoginPage); // Display the current page
            setupLoginPagination(); // Update pagination info
        }

        function goToLoginPage() {
            const totalLoginPages = Math.ceil(totalLoginRows / loginRowsPerPage);
            const inputPage = parseInt(document.getElementById('loginPageInput').value);
            if (inputPage >= 1 && inputPage <= totalLoginPages) {
                currentLoginPage = inputPage; // Set current page to input value
                displayLoginPage(currentLoginPage); // Display the current page
                setupLoginPagination(); // Update pagination info
            } else {
                alert(`Please enter a valid page number between 1 and ${totalLoginPages}.`);
            }
        }

        function displayLoginPage(page) {
            const recentLoginsBody = document.getElementById('recentLoginsBody');
            recentLoginsBody.innerHTML = ''; // Clear current data

            const start = (page - 1) * loginRowsPerPage;
            const end = start + loginRowsPerPage;
            const paginatedLoginData = recentLoginData.slice(start, end); // Use stored data

            paginatedLoginData.forEach(item => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${item.timestamp}</td>
                    <td>${item.email}</td>
                    <td>${item.username}</td>
                `;
                recentLoginsBody.appendChild(row);
            });
        }

        // Fetch recent login data on page load
        fetchRecentLoginData();

        function displayFilteredData(filteredData) {
            const userDataBody = document.getElementById('userDataBody');
            userDataBody.innerHTML = ''; // Clear current data

            // Calculate the total number of pages based on filtered data
            const totalFilteredRows = filteredData.length;
            const totalPages = Math.ceil(totalFilteredRows / rowsPerPage);
            
            // Update pagination info
            if (!isTimerTriggered) {
                setupPagination(totalFilteredRows); // Update pagination based on filtered data
            } else {
                setupPagination(totalFilteredRows, false);
            }

            // Determine the current page's data to display
            const start = (currentPage - 1) * rowsPerPage;
            const end = start + rowsPerPage;
            const paginatedData = filteredData.slice(start, end); // Use filtered data

            // Display the paginated filtered data
            paginatedData.forEach(item => {
                const row = document.createElement('tr');
                const formattedTimestamp = new Date(item.timestamp * 1000).toISOString().slice(0, 19).replace('T', ' '); // Format timestamp
                row.innerHTML = `
                    <td>${formattedTimestamp}</td>
                    <td>${item.ip}</td>
                    <td>${item.packet_size}</td>
                    <td>${item.request_rate}</td>
                    <td>${item.label}</td>
                `;
                userDataBody.appendChild(row);
            });
        }
        
        // Update the chart based on the selected time range
        function updateChart(timeRange) {
            currentTimeRange = timeRange; // Update the current time range
            const filteredData = filterDataByTimeRange(timeRange);
            const labels = getLabels(timeRange);
            const datasets = prepareDatasets(filteredData);

            if (attackChart) {
                attackChart.destroy(); // Destroy the previous chart instance
            }

            const ctx = document.getElementById('attackChart').getContext('2d');
            attackChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Packets'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index', // Show tooltip for all datasets at the same index
                            intersect: false, // Allow tooltip to show when hovering over the line
                            callbacks: {
                                label: function(tooltipItem) {
                                    const label = tooltipItem.dataset.label || '';
                                    const value = tooltipItem.raw; // Get the value for the tooltip
                                    return `${label}: ${value}`; // Customize the tooltip label
                                }
                            }
                        }
                    }
                }
            });
        }

        // Filter data based on the selected time range
        function filterDataByTimeRange(timeRange) {
            const now = Date.now() / 1000; // Current time in seconds
            let cutoff;

            switch (timeRange) {
                case '24h':
                    cutoff = now - 86400; // 24 hours
                    break;
                case '168h':
                    cutoff = now - 604800; // 168 hours
                    break;
                case '30d':
                    cutoff = now - 2592000; // 30 days
                    break;
                case '90d':
                    cutoff = now - 7776000; // 90 days
                    break;
                case '6m':
                    cutoff = now - 15552000; // 6 months
                    break;
                case '12m':
                    cutoff = now - 31536000; // 12 months
                    break;
                case 'all':
                    return attackData; // No filtering
            }

            return attackData.filter(item => item.timestamp >= cutoff);
        }

        // Prepare datasets for the chart
        function prepareDatasets(data) {
            const labels = ['Normal', 'DDOS', 'Port_Scan'];
            const datasets = labels.map(label => {
                const counts = []; // Array to hold counts for each time interval

                // Initialize counts based on the time range
                const timeRange = currentTimeRange; // Use the current time range
                const now = Date.now() / 1000; // Current time in seconds

                switch (timeRange) {
                    case '24h':
                        for (let i = 0; i < 24; i++) {
                            const start = now - (i + 1) * 3600; // Start of the hour
                            const end = now - i * 3600; // End of the hour
                            const count = data.filter(item => item.label === label && item.timestamp >= start && item.timestamp < end).length;
                            counts.unshift(count); // Add count to the beginning of the array
                        }
                        break;
                    case '168h':
                        for (let i = 0; i < 168; i++) {
                            const start = now - (i + 1) * 3600; // Start of the hour
                            const end = now - i * 3600; // End of the hour
                            const count = data.filter(item => item.label === label && item.timestamp >= start && item.timestamp < end).length;
                            counts.unshift(count); // Add count to the beginning of the array
                        }
                        break;
                    case '30d':
                        for (let i = 0; i < 30; i++) {
                            const start = now - (i + 1) * 86400; // Start of the day
                            const end = now - i * 86400; // End of the day
                            const count = data.filter(item => item.label === label && item.timestamp >= start && item.timestamp < end).length;
                            counts.unshift(count); // Add count to the beginning of the array
                        }
                        break;
                    case '90d':
                        for (let i = 0; i < 90; i++) {
                            const start = now - (i + 1) * 86400; // Start of the day
                            const end = now - i * 86400; // End of the day
                            const count = data.filter(item => item.label === label && item.timestamp >= start && item.timestamp < end).length;
                            counts.unshift(count); // Add count to the beginning of the array
                        }
                        break;
                    case '6m':
                        for (let i = 0; i < 26; i++) {
                            const start = now - (i + 1) * 604800; // Start of the week
                            const end = now - i * 604800; // End of the week
                            const count = data.filter(item => item.label === label && item.timestamp >= start && item.timestamp < end).length;
                            counts.unshift(count); // Add count to the beginning of the array
                        }
                        break;
                    case '12m':
                        for (let i = 0; i < 53; i++) {
                            const start = now - (i + 1) * 604800; // Start of the week
                            const end = now - i * 604800; // End of the week
                            const count = data.filter(item => item.label === label && item.timestamp >= start && item.timestamp < end).length;
                            counts.unshift(count); // Add count to the beginning of the array
                        }
                        break;
                    case 'all':
                        const totalMonths = Math.ceil((now - Math.min(...data.map(item => item.timestamp))) / (2592000)); // Calculate total months
                        for (let i = 0; i < totalMonths; i++) {
                            const start = now - (i + 1) * 2592000; // Start of the month
                            const end = now - i * 2592000; // End of the month
                            const count = data.filter(item => item.label === label && item.timestamp >= start && item.timestamp < end).length;
                            counts.unshift(count); // Add count to the beginning of the array
                        }
                        break;
                }

                return {
                    label: label,
                    data: counts,
                    fill: true,
                    backgroundColor: getColor(label),
                    borderColor: getColor(label),
                    borderWidth: 1
                };
            });

            return datasets;
        }

        // Get color for each label
        function getColor(label) {
            switch (label) {
                case 'Normal':
                    return 'rgba(75, 192, 192, 0.2)';
                case 'DDOS':
                    return 'rgba(255, 99, 132, 0.2)';
                case 'Port_Scan':
                    return 'rgba(255, 206, 86, 0.2)';
                default:
                    return 'rgba(0, 0, 0, 0.2)';
            }
        }

        // Get labels for the x-axis based on the time range
        function getLabels(timeRange) {
            const labels = [];
            const now = new Date();
            switch (timeRange) {
                case '24h':
                    for (let i = 0; i < 24; i++) {
                        const hourDate = new Date(now.getTime() - (i * 3600000));
                        hourDate.setMinutes(0, 0); // Set minutes and seconds to zero
                        labels.push(hourDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
                    }
                    break;
                case '168h':
                    for (let i = 0; i < 168; i++) {
                        const hourDate = new Date(now.getTime() - (i * 3600000));
                        hourDate.setMinutes(0, 0); // Set minutes and seconds to zero
                        labels.push(hourDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
                    }
                    break;
                case '30d':
                    for (let i = 0; i < 30; i++) {
                        labels.push(new Date(now.getTime() - (i * 86400000)).toLocaleDateString());
                    }
                    break;
                case '90d':
                    for (let i = 0; i < 90; i++) {
                        labels.push(new Date(now.getTime() - (i * 86400000)).toLocaleDateString());
                    }
                    break;
                case '6m':
                    for (let i = 0; i < 26; i++) {
                        labels.push(new Date(now.getTime() - (i * 604800000)).toLocaleDateString());
                    }
                    break;
                case '12m':
                    for (let i = 0; i < 53; i++) {
                        labels.push(new Date(now.getTime() - (i * 604800000)).toLocaleDateString());
                    }
                    break;
                case 'all':
                    // Calculate the total number of months from the oldest timestamp
                    const oldestTimestamp = Math.min(...attackData.map(item => item.timestamp));
                    const oldestDate = new Date(oldestTimestamp * 1000);
                    const totalMonths = Math.ceil((now - oldestDate) / (2592000 * 1000)); // Calculate total months

                    for (let i = 0; i < totalMonths; i++) {
                        labels.push(new Date(now.getTime() - (i * 2592000000)).toLocaleDateString());
                    }
                    break;
            }
            return labels.reverse(); // Reverse to show the latest first
        }

        // Existing event listener for pageInput
        document.getElementById('pageInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                goToPage();
            }
        });
        // New event listener for loginPageInput
        document.getElementById('loginPageInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                goToLoginPage();
            }
        });
    </script>
</body>
</html>